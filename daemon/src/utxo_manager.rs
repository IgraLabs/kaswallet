use crate::address_manager::{AddressManager, AddressSet};
use common::model::{
    WalletAddress, WalletOutpoint, WalletSignableTransaction, WalletUtxo, WalletUtxoEntry,
};
use itertools::Itertools;
use kaspa_consensus_core::config::params::Params;
use kaspa_rpc_core::{GetBlockDagInfoResponse, RpcMempoolEntryByAddress, RpcUtxosByAddressesEntry};
use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct UtxoManager {
    address_manager: Arc<Mutex<AddressManager>>,
    coinbase_maturity: u64, // Is different in testnet

    utxos_sorted_by_amount: Vec<WalletUtxo>,
    utxos_by_outpoint: HashMap<WalletOutpoint, WalletUtxo>,
    // Since the sync stage of address collection only picks up on addresses that have accepted
    // (non-mempool) balance, we might miss some mempool outputs that are not yet accepted.
    // To mitigate this we maintain a list of mempool transactions generated by this wallet
    // that should be accepted soon, but are not yet accepted by consensus.
    mempool_transactions: Vec<WalletSignableTransaction>,
}

impl UtxoManager {
    pub fn new(
        address_manager: Arc<Mutex<AddressManager>>,
        consensus_params: Params,
        block_dag_info: GetBlockDagInfoResponse,
    ) -> Self {
        let coinbase_maturity = consensus_params
            .coinbase_maturity()
            .get(block_dag_info.virtual_daa_score);

        Self {
            address_manager,
            coinbase_maturity,
            utxos_sorted_by_amount: Vec::new(),
            utxos_by_outpoint: HashMap::new(),
            mempool_transactions: Vec::new(),
        }
    }

    pub fn utxos_sorted_by_amount(&self) -> Vec<WalletUtxo> {
        self.utxos_sorted_by_amount.clone()
    }

    pub fn utxos_by_outpoint(&self) -> HashMap<WalletOutpoint, WalletUtxo> {
        self.utxos_by_outpoint.clone()
    }

    pub async fn add_mempool_transaction(&mut self, transaction: &WalletSignableTransaction) {
        self.mempool_transactions.push(transaction.clone());
        self.apply_mempool_transaction(transaction).await;
    }

    async fn apply_mempool_transaction(&mut self, transaction: &WalletSignableTransaction) {
        let tx = &transaction.transaction.unwrap_ref().tx;

        for input in &tx.inputs {
            let outpoint = input.previous_outpoint;
            self.remove_utxo(&outpoint.into());
        }

        for (i, output) in tx.outputs.iter().enumerate() {
            let wallet_address: Option<WalletAddress>;
            {
                let address_manager = self.address_manager.lock().await;
                wallet_address = address_manager
                    .wallet_address_from_string(&transaction.address_by_output_index[i].to_string())
                    .await;
            }
            if wallet_address.is_none() {
                // this means payment is not to this wallet
                continue;
            }
            let wallet_address = wallet_address.unwrap();
            let outpoint = WalletOutpoint {
                transaction_id: tx.id(),
                index: i as u32,
            };
            let utxo = WalletUtxo::new(
                outpoint.clone(),
                WalletUtxoEntry {
                    amount: output.value,
                    script_public_key: output.script_public_key.clone(),
                    block_daa_score: 0,
                    is_coinbase: false,
                },
                wallet_address,
            );
            self.insert_utxo(outpoint, utxo);
        }
    }

    fn insert_utxo(&mut self, outpoint: WalletOutpoint, utxo: WalletUtxo) {
        self.utxos_by_outpoint.insert(outpoint, utxo.clone());
        let position = self
            .utxos_sorted_by_amount
            .binary_search_by(|existing_utxo| {
                existing_utxo.utxo_entry.amount.cmp(&utxo.utxo_entry.amount)
            });
        let position = position.unwrap_or_else(|position| position);
        self.utxos_sorted_by_amount.insert(position, utxo);
    }

    fn contains_utxo(&self, outpoint: &WalletOutpoint) -> bool {
        self.utxos_by_outpoint.contains_key(outpoint)
    }

    fn remove_utxo(&mut self, outpoint: &WalletOutpoint) {
        self.utxos_by_outpoint.remove(outpoint).unwrap();
        let (position, _) = self
            .utxos_sorted_by_amount
            .iter()
            .find_position(|existing_utxo| existing_utxo.outpoint.eq(&outpoint))
            .unwrap();
        self.utxos_sorted_by_amount.remove(position);
    }

    pub async fn update_utxo_set(
        &mut self,
        rpc_utxo_entries: Vec<RpcUtxosByAddressesEntry>,
        rpc_mempool_utxo_entries: Vec<RpcMempoolEntryByAddress>,
    ) -> Result<(), Box<dyn Error + Send + Sync>> {
        let mut wallet_utxos: Vec<WalletUtxo> = vec![];

        let mut exculde: HashSet<WalletOutpoint> = HashSet::new();
        for rpc_mempool_entries_by_address in &rpc_mempool_utxo_entries {
            for sending_rpc_mempool_entry in &rpc_mempool_entries_by_address.sending {
                for input in &sending_rpc_mempool_entry.transaction.inputs {
                    exculde.insert(input.previous_outpoint.into());
                }
            }
        }

        let address_set: AddressSet;
        {
            let address_manager = self.address_manager.lock().await;
            address_set = address_manager.address_set().await;
        }

        for rpc_utxo_entry in &rpc_utxo_entries {
            let wallet_outpoint: WalletOutpoint = rpc_utxo_entry.outpoint.into();
            if exculde.contains(&wallet_outpoint) {
                continue;
            }

            let wallet_utxo_entry: WalletUtxoEntry = rpc_utxo_entry.utxo_entry.clone().into();

            let address = address_set
                .get(&rpc_utxo_entry.address.as_ref().unwrap().to_string())
                .unwrap();

            let wallet_utxo = WalletUtxo::new(wallet_outpoint, wallet_utxo_entry, address.clone());

            wallet_utxos.push(wallet_utxo);
        }

        for rpc_mempool_entry in rpc_mempool_utxo_entries {
            for receiving_rpc_mempool_entry in &rpc_mempool_entry.receiving {
                let transaction = &receiving_rpc_mempool_entry.transaction;
                let Some(transaction_verbose_data) = &transaction.verbose_data else {
                    panic!("transaction verbose data missing")
                };
                for (i, output) in transaction.outputs.iter().enumerate() {
                    let Some(output_verbose_data) = &output.verbose_data else {
                        panic!("output verbose data missing")
                    };
                    let address_manager = self.address_manager.lock().await;
                    let address = address_manager
                        .wallet_address_from_string(
                            &output_verbose_data
                                .script_public_key_address
                                .address_to_string(),
                        )
                        .await;
                    if address.is_none() {
                        // this means this output is not to this wallet
                        continue;
                    }

                    let wallet_outpoint =
                        WalletOutpoint::new(transaction_verbose_data.transaction_id, i as u32);

                    if exculde.contains(&wallet_outpoint) {
                        continue;
                    }
                    let utxo_entry = WalletUtxoEntry::new(
                        output.value,
                        output.script_public_key.clone(),
                        0,
                        false,
                    );

                    let utxo = WalletUtxo::new(wallet_outpoint, utxo_entry, address.unwrap());

                    wallet_utxos.push(utxo);
                }
            }
        }

        self.update_utxos_sorted_by_amount(wallet_utxos.clone());
        self.update_utxos_by_outpoint(wallet_utxos);

        self.apply_mempool_transactions_after_update().await;
        Ok(())
    }

    async fn apply_mempool_transactions_after_update(&mut self) {
        let previous_mempool_transactions = std::mem::take(&mut self.mempool_transactions);
        self.mempool_transactions = vec![];
        'outer: for transaction in &previous_mempool_transactions {
            for input in transaction.transaction.unwrap_ref().tx.inputs.iter() {
                let outpoint = input.previous_outpoint;
                if !self.contains_utxo(&outpoint.into()) {
                    // this means this transaction was either accepted or double-spent
                    continue 'outer;
                }
            }
            self.add_mempool_transaction(transaction).await;
        }
    }

    fn update_utxos_sorted_by_amount(&mut self, mut wallet_utxos: Vec<WalletUtxo>) {
        wallet_utxos.sort_by(|a, b| a.utxo_entry.amount.cmp(&b.utxo_entry.amount));
        self.utxos_sorted_by_amount = wallet_utxos;
    }

    fn update_utxos_by_outpoint(&mut self, wallet_utxos: Vec<WalletUtxo>) {
        self.utxos_by_outpoint.clear();
        for wallet_utxo in wallet_utxos {
            self.utxos_by_outpoint
                .insert(wallet_utxo.outpoint.clone(), wallet_utxo);
        }
    }

    pub fn is_utxo_pending(&self, utxo: &WalletUtxo, virtual_daa_score: u64) -> bool {
        if !utxo.utxo_entry.is_coinbase {
            return false;
        }

        utxo.utxo_entry.block_daa_score + self.coinbase_maturity > virtual_daa_score
    }
}
