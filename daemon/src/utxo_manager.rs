use crate::address_manager::{AddressManager, AddressSet};
use common::model::{WalletOutpoint, WalletSignableTransaction, WalletUtxo, WalletUtxoEntry};
use kaspa_addresses::Address;
use kaspa_consensus_core::config::params::Params;
use kaspa_rpc_core::{GetBlockDagInfoResponse, RpcMempoolEntryByAddress, RpcUtxosByAddressesEntry};
use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct UtxoManager {
    address_manager: Arc<Mutex<AddressManager>>,
    coinbase_maturity: u64, // Is different in testnet

    utxos_by_outpoint: HashMap<WalletOutpoint, WalletUtxo>,
    // Sorted by (amount, outpoint) so the outpoint can be used as a deterministic tiebreaker.
    // This avoids cloning/storing the full `WalletUtxo` twice (once in a Vec and once in a HashMap).
    utxo_keys_sorted_by_amount: Vec<(u64, WalletOutpoint)>,
    // Since the sync stage of address collection only picks up on addresses that have accepted
    // (non-mempool) balance, we might miss some mempool outputs that are not yet accepted.
    // To mitigate this we maintain a list of mempool transactions generated by this wallet
    // that should be accepted soon, but are not yet accepted by consensus.
    mempool_transactions: Vec<WalletSignableTransaction>,
}

impl UtxoManager {
    pub fn new(
        address_manager: Arc<Mutex<AddressManager>>,
        consensus_params: Params,
        block_dag_info: GetBlockDagInfoResponse,
    ) -> Self {
        let coinbase_maturity = consensus_params
            .coinbase_maturity()
            .get(block_dag_info.virtual_daa_score);

        Self {
            address_manager,
            coinbase_maturity,
            utxos_by_outpoint: HashMap::new(),
            utxo_keys_sorted_by_amount: Vec::new(),
            mempool_transactions: Vec::new(),
        }
    }

    pub fn utxos_sorted_by_amount(&self) -> impl Iterator<Item = &WalletUtxo> + '_ {
        self.utxo_keys_sorted_by_amount.iter().map(|(_, outpoint)| {
            self.utxos_by_outpoint
                .get(outpoint)
                .expect("utxo_keys_sorted_by_amount contains unknown outpoint")
        })
    }

    pub fn utxos_by_outpoint(&self) -> &HashMap<WalletOutpoint, WalletUtxo> {
        &self.utxos_by_outpoint
    }

    pub fn get_utxo_by_outpoint(&self, outpoint: &WalletOutpoint) -> Option<&WalletUtxo> {
        self.utxos_by_outpoint.get(outpoint)
    }

    pub async fn add_mempool_transaction(&mut self, transaction: &WalletSignableTransaction) {
        self.mempool_transactions.push(transaction.clone());
        self.apply_mempool_transaction(transaction).await;
    }

    async fn apply_mempool_transaction(&mut self, transaction: &WalletSignableTransaction) {
        let tx = &transaction.transaction.unwrap_ref().tx;

        for input in &tx.inputs {
            let outpoint = input.previous_outpoint;
            self.remove_utxo(&outpoint.into());
        }

        let mut outputs_to_insert = Vec::new();
        {
            let address_manager = self.address_manager.lock().await;
            for (i, output) in tx.outputs.iter().enumerate() {
                let address_string = transaction.address_by_output_index[i].to_string();
                let wallet_address = address_manager
                    .wallet_address_from_string(&address_string)
                    .await;
                let Some(wallet_address) = wallet_address else {
                    // this means payment is not to this wallet
                    continue;
                };
                let outpoint = WalletOutpoint {
                    transaction_id: tx.id(),
                    index: i as u32,
                };
                let utxo_entry = WalletUtxoEntry {
                    amount: output.value,
                    script_public_key: output.script_public_key.clone(),
                    block_daa_score: 0,
                    is_coinbase: false,
                };
                outputs_to_insert.push((outpoint, utxo_entry, wallet_address));
            }
        }

        for (outpoint, utxo_entry, wallet_address) in outputs_to_insert {
            let utxo = WalletUtxo::new(
                outpoint.clone(),
                utxo_entry,
                wallet_address,
            );
            self.insert_utxo(outpoint, utxo);
        }
    }

    fn insert_utxo(&mut self, outpoint: WalletOutpoint, utxo: WalletUtxo) {
        let amount = utxo.utxo_entry.amount;

        let previous = self.utxos_by_outpoint.insert(outpoint.clone(), utxo);
        debug_assert!(previous.is_none(), "UTXO outpoint inserted twice");

        let key = (amount, outpoint);
        let position = self
            .utxo_keys_sorted_by_amount
            .binary_search(&key)
            .unwrap_or_else(|position| position);
        self.utxo_keys_sorted_by_amount.insert(position, key);
    }

    fn contains_utxo(&self, outpoint: &WalletOutpoint) -> bool {
        self.utxos_by_outpoint.contains_key(outpoint)
    }

    fn remove_utxo(&mut self, outpoint: &WalletOutpoint) {
        let utxo = self
            .utxos_by_outpoint
            .remove(outpoint)
            .expect("attempted to remove unknown UTXO");

        let key = (utxo.utxo_entry.amount, outpoint.clone());
        let position = self
            .utxo_keys_sorted_by_amount
            .binary_search(&key)
            .expect("utxo_keys_sorted_by_amount missing removed outpoint");
        self.utxo_keys_sorted_by_amount.remove(position);
    }

    pub async fn update_utxo_set(
        &mut self,
        rpc_utxo_entries: Vec<RpcUtxosByAddressesEntry>,
        rpc_mempool_utxo_entries: Vec<RpcMempoolEntryByAddress>,
    ) -> Result<(), Box<dyn Error + Send + Sync>> {
        let mut exculde: HashSet<WalletOutpoint> = HashSet::new();
        for rpc_mempool_entries_by_address in &rpc_mempool_utxo_entries {
            for sending_rpc_mempool_entry in &rpc_mempool_entries_by_address.sending {
                for input in &sending_rpc_mempool_entry.transaction.inputs {
                    exculde.insert(input.previous_outpoint.into());
                }
            }
        }

        let address_set: AddressSet;
        {
            let address_manager = self.address_manager.lock().await;
            address_set = address_manager.address_set().await;
        }

        let mut address_map = HashMap::with_capacity(address_set.len());
        for (address_string, wallet_address) in &address_set {
            let address = Address::try_from(address_string.as_str()).map_err(|err| {
                format!("invalid address in wallet address_set ({address_string}): {err}")
            })?;
            address_map.insert(address, wallet_address.clone());
        }

        // Rebuild from scratch while reusing allocations where possible.
        self.utxos_by_outpoint.clear();
        self.utxo_keys_sorted_by_amount.clear();
        self.utxos_by_outpoint.reserve(rpc_utxo_entries.len());
        self.utxo_keys_sorted_by_amount.reserve(rpc_utxo_entries.len());

        for rpc_utxo_entry in rpc_utxo_entries {
            let wallet_outpoint: WalletOutpoint = rpc_utxo_entry.outpoint.into();
            if exculde.contains(&wallet_outpoint) {
                continue;
            }

            let wallet_utxo_entry: WalletUtxoEntry = rpc_utxo_entry.utxo_entry.into();
            let amount = wallet_utxo_entry.amount;

            let Some(address) = &rpc_utxo_entry.address else {
                continue;
            };
            let wallet_address = address_map
                .get(address)
                .ok_or_else(|| {
                    format!(
                        "UTXO address {} not found in wallet address_set",
                        address.to_string()
                    )
                })?
                .clone();

            let wallet_utxo =
                WalletUtxo::new(wallet_outpoint.clone(), wallet_utxo_entry, wallet_address);

            self.utxos_by_outpoint
                .insert(wallet_outpoint.clone(), wallet_utxo);
            self.utxo_keys_sorted_by_amount
                .push((amount, wallet_outpoint));
        }

        for rpc_mempool_entry in rpc_mempool_utxo_entries {
            for receiving_rpc_mempool_entry in &rpc_mempool_entry.receiving {
                let transaction = &receiving_rpc_mempool_entry.transaction;
                let Some(transaction_verbose_data) = &transaction.verbose_data else {
                    panic!("transaction verbose data missing")
                };
                for (i, output) in transaction.outputs.iter().enumerate() {
                    let Some(output_verbose_data) = &output.verbose_data else {
                        panic!("output verbose data missing")
                    };
                    let address_string = output_verbose_data
                        .script_public_key_address
                        .address_to_string();
                    let Some(address) = address_set.get(&address_string) else {
                        // this means this output is not to this wallet
                        continue;
                    };

                    let wallet_outpoint =
                        WalletOutpoint::new(transaction_verbose_data.transaction_id, i as u32);

                    if exculde.contains(&wallet_outpoint) {
                        continue;
                    }
                    let utxo_entry = WalletUtxoEntry::new(
                        output.value,
                        output.script_public_key.clone(),
                        0,
                        false,
                    );

                    let utxo =
                        WalletUtxo::new(wallet_outpoint.clone(), utxo_entry, address.clone());

                    self.utxos_by_outpoint
                        .insert(wallet_outpoint.clone(), utxo);
                    self.utxo_keys_sorted_by_amount
                        .push((output.value, wallet_outpoint));
                }
            }
        }

        self.utxo_keys_sorted_by_amount.sort_unstable();

        self.apply_mempool_transactions_after_update().await;
        Ok(())
    }

    async fn apply_mempool_transactions_after_update(&mut self) {
        let previous_mempool_transactions = std::mem::take(&mut self.mempool_transactions);
        self.mempool_transactions = vec![];
        'outer: for transaction in &previous_mempool_transactions {
            for input in transaction.transaction.unwrap_ref().tx.inputs.iter() {
                let outpoint = input.previous_outpoint;
                if !self.contains_utxo(&outpoint.into()) {
                    // this means this transaction was either accepted or double-spent
                    continue 'outer;
                }
            }
            self.add_mempool_transaction(transaction).await;
        }
    }

    pub fn is_utxo_pending(&self, utxo: &WalletUtxo, virtual_daa_score: u64) -> bool {
        if !utxo.utxo_entry.is_coinbase {
            return false;
        }

        utxo.utxo_entry.block_daa_score + self.coinbase_maturity > virtual_daa_score
    }
}

#[cfg(test)]
mod tests {
    use super::UtxoManager;
    use crate::address_manager::AddressManager;
    use common::keys::Keys;
    use common::model::{Keychain, WalletAddress, WalletOutpoint, WalletUtxo, WalletUtxoEntry};
    use kaspa_bip32::Prefix as XPubPrefix;
    use kaspa_consensus_core::tx::ScriptPublicKey;
    use kaspa_hashes::Hash;
    use std::collections::HashMap;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    fn hash(byte: u8) -> Hash {
        Hash::from_bytes([byte; 32])
    }

    fn make_manager() -> UtxoManager {
        let keys = Arc::new(Keys::new(
            "unused".to_string(),
            1,
            vec![],
            XPubPrefix::XPUB,
            vec![],
            0,
            0,
            1,
            0,
        ));
        let address_manager = AddressManager::new(keys, kaspa_addresses::Prefix::Mainnet);

        UtxoManager {
            address_manager: Arc::new(Mutex::new(address_manager)),
            coinbase_maturity: 0,
            utxos_by_outpoint: HashMap::new(),
            utxo_keys_sorted_by_amount: Vec::new(),
            mempool_transactions: Vec::new(),
        }
    }

    fn make_utxo(amount: u64, txid_byte: u8, index: u32) -> WalletUtxo {
        let outpoint = WalletOutpoint {
            transaction_id: hash(txid_byte),
            index,
        };
        let utxo_entry = WalletUtxoEntry {
            amount,
            script_public_key: ScriptPublicKey::from_vec(0, vec![]),
            block_daa_score: 0,
            is_coinbase: false,
        };
        let address = WalletAddress::new(0, 0, Keychain::External);
        WalletUtxo::new(outpoint, utxo_entry, address)
    }

    #[test]
    fn insert_remove_keeps_sorted_keys_consistent() {
        let mut manager = make_manager();

        let utxo_a = make_utxo(50, 1, 0);
        let utxo_b = make_utxo(10, 2, 0);
        let utxo_c = make_utxo(50, 0, 0);

        manager.insert_utxo(utxo_a.outpoint.clone(), utxo_a.clone());
        manager.insert_utxo(utxo_b.outpoint.clone(), utxo_b.clone());
        manager.insert_utxo(utxo_c.outpoint.clone(), utxo_c.clone());

        // Keys stay sorted by (amount, outpoint).
        let mut sorted = manager.utxo_keys_sorted_by_amount.clone();
        sorted.sort();
        assert_eq!(manager.utxo_keys_sorted_by_amount, sorted);

        let amounts: Vec<u64> = manager
            .utxos_sorted_by_amount()
            .map(|utxo| utxo.utxo_entry.amount)
            .collect();
        assert_eq!(amounts, vec![10, 50, 50]);

        manager.remove_utxo(&utxo_a.outpoint);
        assert!(manager.utxos_by_outpoint.get(&utxo_a.outpoint).is_none());

        let mut sorted = manager.utxo_keys_sorted_by_amount.clone();
        sorted.sort();
        assert_eq!(manager.utxo_keys_sorted_by_amount, sorted);

        let amounts: Vec<u64> = manager
            .utxos_sorted_by_amount()
            .map(|utxo| utxo.utxo_entry.amount)
            .collect();
        assert_eq!(amounts, vec![10, 50]);
    }
}
